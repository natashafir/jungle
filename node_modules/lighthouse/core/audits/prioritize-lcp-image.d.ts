export default PrioritizeLcpImage;
export type InitiatorPath = Array<{
    url: string;
    initiatorType: string;
}>;
/**
 * @typedef {Array<{url: string, initiatorType: string}>} InitiatorPath
 */
declare class PrioritizeLcpImage extends Audit {
    /**
     *
     * @param {LH.Artifacts.NetworkRequest} request
     * @param {LH.Artifacts.NetworkRequest} mainResource
     * @param {Array<LH.Gatherer.Simulation.GraphNode>} initiatorPath
     * @return {boolean}
     */
    static shouldPreloadRequest(request: LH.Artifacts.NetworkRequest, mainResource: LH.Artifacts.NetworkRequest, initiatorPath: Array<LH.Gatherer.Simulation.GraphNode>): boolean;
    /**
     * @param {LH.Gatherer.Simulation.GraphNode} graph
     * @param {string} imageUrl
     * @return {{lcpNode: LH.Gatherer.Simulation.GraphNetworkNode|undefined, path: Array<LH.Gatherer.Simulation.GraphNetworkNode>|undefined}}
     */
    static findLCPNode(graph: LH.Gatherer.Simulation.GraphNode, imageUrl: string): {
        lcpNode: LH.Gatherer.Simulation.GraphNetworkNode | undefined;
        path: Array<LH.Gatherer.Simulation.GraphNetworkNode> | undefined;
    };
    /**
     * @param {LH.Artifacts.NetworkRequest} mainResource
     * @param {LH.Gatherer.Simulation.GraphNode} graph
     * @param {string | undefined} lcpUrl
     * @return {{lcpNodeToPreload?: LH.Gatherer.Simulation.GraphNetworkNode, initiatorPath?: InitiatorPath}}
     */
    static getLCPNodeToPreload(mainResource: LH.Artifacts.NetworkRequest, graph: LH.Gatherer.Simulation.GraphNode, lcpUrl: string | undefined): {
        lcpNodeToPreload?: import("../lib/dependency-graph/network-node.js").NetworkNode | undefined;
        initiatorPath?: InitiatorPath | undefined;
    };
    /**
     * Match the LCP event with the paint event to get the URL of the image actually painted.
     * This could differ from the `ImageElement` associated with the nodeId if e.g. the LCP
     * was a pseudo-element associated with a node containing a smaller background-image.
     * @param {LH.Trace} trace
     * @param {LH.Artifacts.ProcessedNavigation} processedNavigation
     * @return {string | undefined}
     */
    static getLcpUrl(trace: LH.Trace, processedNavigation: LH.Artifacts.ProcessedNavigation): string | undefined;
    /**
     * Computes the estimated effect of preloading the LCP image.
     * @param {LH.Artifacts.TraceElement} lcpElement
     * @param {LH.Gatherer.Simulation.GraphNetworkNode|undefined} lcpNode
     * @param {LH.Gatherer.Simulation.GraphNode} graph
     * @param {LH.Gatherer.Simulation.Simulator} simulator
     * @return {{wastedMs: number, results: Array<{node: LH.Audit.Details.NodeValue, url: string, wastedMs: number}>}}
     */
    static computeWasteWithGraph(lcpElement: LH.Artifacts.TraceElement, lcpNode: LH.Gatherer.Simulation.GraphNetworkNode | undefined, graph: LH.Gatherer.Simulation.GraphNode, simulator: LH.Gatherer.Simulation.Simulator): {
        wastedMs: number;
        results: {
            node: LH.Audit.Details.NodeValue;
            url: string;
            wastedMs: number;
        }[];
    };
    /**
     * @param {LH.Artifacts} artifacts
     * @param {LH.Audit.Context} context
     * @return {Promise<LH.Audit.Product>}
     */
    static audit(artifacts: LH.Artifacts, context: LH.Audit.Context): Promise<LH.Audit.Product>;
}
export namespace UIStrings {
    const title: string;
    const description: string;
}
import { Audit } from "./audit.js";
import { NetworkRequest } from "../lib/network-request.js";
import { ProcessedNavigation } from "../computed/processed-navigation.js";
//# sourceMappingURL=prioritize-lcp-image.d.ts.map